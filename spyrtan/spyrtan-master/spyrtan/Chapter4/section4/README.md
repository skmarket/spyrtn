# 4-4. イテレータ・ジェネレーター / 内包表記

### イテレータ・ジェネレータとは


Python にはイテレータ・ジェネレータというものがあります。<br>
しかし、難しい概念で正確に伝えることが難しいのでここでは雰囲気をお伝えします。

まず、「イテレータ」ですが

1. 一連のデータを保持する
2. `next()` によって次の値を返す

という構造を持つものです。<br>
つまり、ロケット鉛筆のような感じで `next()` をするたびに次の要素ができてきて空になると何も出てこなくなるようなデータ型です。

次にジェネレータは、イテレータを作ることができる設計図のようなものです。<br>
ちなみにこの設計図によって生み出されたイテレータは、ジェネレータ（イテレータ）と呼ばれます。<br>
関連記事を見ると、イテレータとジェネレータを混同したものがありますが、名前がややこしいためですので注意してください。

これまで扱ったジェネレータの１つは、 `range()` です。<br>
たしかに for に対して、一連のデータを提供して値を１つずつ返していましたね。

また、このような値を１つずつ返すことができる性質をもつデータ型を「イテラブル」なデータ型といいます。

---

### iterable なデータ型

代表的なイテラブルなデータ型について紹介します。

- 文字列
- リスト
- タプル
- 集合
- rangeオブジェクト
- 辞書

１つずつ挙動を確認してみましょう。<br>
まず文字列についてですが、以下のようにすると一文字ずつ表示させることができます。<br>
もじ１つ１つが要素となり、 `next()` によって次の文字が返されていますね。

```python
name = 'kondo'

for c in name:
    print(c)
```

つぎにリストです

```python
fluits = ['banana', 'lemon', 'peach']

for fluit_name in fluits:
    print(fluit_name)
```

タプルも同様に

```python
alphabet_pairs = (['k', 'K'], ['a', 'A'], ['b', 'B'])

for pair in alphabet_pairs:
    print(pair)
```

というように表示できます。集合と range オブジェクトについても確認してみてくださいね。<br>
レンジオブジェクトというのは、section2 で出てきた `range(10)` のようなやつです。

最後に辞書についても確認していきましょう。<br>
辞書型については、`.` を付けた後に、`keys()` とすることでキーをイテラブルに、<br>
`values()` とすることでバリューをイテラブルに取得することができます。

```python
ranking = {1: 'tanaka', 2: 'tadokoro', 3: 'takase'}

for rank_key in ranking.keys():
    print(rank_key)

for rank_value in ranking.value():
    print(rank_value)
```

また、`items()` という関数を利用すると `(key, value)` というタプルを順番に取得することができます。

```python
ranking = {1: 'tanaka', 2: 'tadokoro', 3: 'takase'}

for rank, name in ranking.items():
    print(rank, name)
```

タプルなので、 `for (rank, name) in ...` と書くのがよさそうに思うかもしれませんが、上の書き方が一般的です。<br>
このようにイテラブルなデータ型をうまく使えるようになると、楽に表示させることができたりするので押さえておきましょう。

---

### 内包表記と使いどころ

さぁ Python で良くつかう上に独特の記法です。<br>

```python
names = ['kondo', 'kobayashi', 'komori', 'komuro']
```

というように名前の一覧があります。<br>
それぞれの人物の点数を辞書型で保存したいです。そこでまず、キーが名前、点数をバリューに持つ辞書を作成しましょう。<br>
ただし、点数は０で初期化されているものとします。

```python
scores = {
    'kondo': 0,
    'kobayashi': 0,
    'komori': 0,
    'komuro': 0
}
```

こんな感じですね。ただ、人数が不確定だったり、多かったりすると大変です。<br>
そこで、動的に(プログラムを利用して可変的に)作成することを考えてみましょう。

```python
scores = {}
for name in names:
    scores[name] = 0
```

という感じでしょうか。<br>
実はこれは

```python
scores = {name: 0 for name in names}
```

と一行で書くことができます。<br>
これは翻訳してみると

`{要素についての処理} for {要素} in {イテラブルなデータ型}`

となっており、要素についての処理が `name: 0` となっています。<br>
たとえばこれを、`name: name + '!'` とすると、名前をキー、名前にビックリマークがついた値をバリューとする辞書型ができあがります。

このような書き方を「内包表記」とよび、今回のものを「辞書内包表記」といいます。<br>
同様にリスト内包表記というものもあります。

テストに不備があり、テストの点数を一律に 10 点上げたい場合は、以下のようにすればOKですね。

```python
scores = [70, 50, 60]
modified_scores = [score + 10 for score in scores]
```

さて、イテラブルなデータ型と内包表記の便利さを理解したところでクイズを解いていきましょう！
